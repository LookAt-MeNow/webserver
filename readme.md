## **服务器框架**

![服务器基本框架](pic/IMG_0551(20240710-090943).PNG)

I/O处理单元 ：处理客户的连接，读写网络数据
逻辑单元：业务进程或线程
存储单元：本地数据库，文件缓存
请求队列：各单元之间的通信方式

---
## **I/O方式**

- 阻塞I/O：
  - 在阻塞I/O模型中，应用程序发起一个I/O操作，然后完全挂起，直到数据准备就绪并且复制到应用程序中。在这个过程中，应用程序不做任何工作，只是等待I/O操作完成。
  - 相当于在餐厅点餐，点完餐后，坐在桌子旁等待食物准备好。在这期间，什么也做不了，只能等待。
- 非阻塞I/O：
  - 非阻塞I/O模型允许应用程序在请求I/O操作后继续执行。应用程序需要不断地询问I/O操作是否完成（即轮询），这可能会导致大量的CPU时间浪费在检查操作状态上。
  - 点了餐后不愿意坐着等，而是每隔一分钟去柜台询问食物是否准备好。在等待的时间里，你可以做其他事情。
- I/O复用：
  - I/O复用允许单个进程监视多个I/O流，等待任一流准备好进行读写操作。select和poll是实现I/O复用的常见系统调用。应用程序在一个阻塞调用中等待多个I/O事件中的任何一个发生。
  - 多人在餐厅点了不同的菜。你负责去柜台询问，一旦任何一个菜准备好了，你就会被通知，然后你可以决定接下来的行动。
- SIGIO信号：
  - 信号驱动I/O模型允许应用程序告诉内核，当数据准备好可以进行I/O操作时，通过信号通知应用程序。应用程序不需要不断检查I/O操作是否完成，从而减少了CPU的使用。
  - 你在餐厅点餐后继续做你的事情，但你告诉服务员，一旦我的食物准备好了，就发一个信号给我。收到信号后，你去取餐。
- 异步I/O：
  - 异步I/O模型允许应用程序发起I/O操作后立即返回，继续执行其他任务。内核会在数据准备好并且已经被复制到应用程序指定的内存区域后通知应用程序I/O操作已经完成。这个模型允许应用程序无需等待或者轮询地检查I/O操作，从而实现了真正的并行执行。
  - 在餐厅点餐后，你做你的事情去了。餐厅不仅会准备你的食物，还会主动把食物送到你的桌子上。你不需要去柜台询问，也不需要等待通知。

**非阻塞I/O要配合I/O通知机制使用，如信号、I/O复用**
**同步I/O就是应用程序通知I/O就绪事件**
**异步I/O就是应用程序通知I/O完成事件**
[异步I/O形象解释](https://www.liaoxuefeng.com/wiki/1016959663602400/1017959540289152)

----
## 事件处理模式

**Reactor模式**

主线程只负责监听文件描述符是否有事件发生，有就通知逻辑单元(工作线程)执行。一般使用同步I/O模型

相当于在一个餐厅中，服务员(主线程)等待客户点餐，然后将客户的点餐记录在菜表上(事件队列)，然后通知厨师(工作线程)做菜。服务员继续等待其他客户点餐。当厨师做好菜，会告诉服务员，服务员再将菜品送到对应的顾客手中。

![Reactor工作流程](pic/image-1.png)

**proactor模式**

Proactor模式将所有I/O操作都交给主线程和内核来处理，工作线程仅仅负责业务逻辑。一般使用异步I/O模型

相当于服务员这次只负责客户的点餐的操作，一旦有客户点餐就立即通知给厨师开始做菜，当厨师做完之后，厨师自己再给客户去送餐

![Proactor工作流程](pic/image-2.png)

**模拟Proactor模式**

利用同步I/O模拟出异步I/O

![模拟proactor](pic/image-3.png)

## 并发模式

*在I/O模型中，“同步”和“异步”区分的是内核向应用程序通知的是何种I/O事件（是就绪事件还是完成事件），以及该由谁来完成I/O读写（是应用程序还是内核）*。在并发模式中，“同步”指的是程序完全按照代码序列的顺序执行；“异步”指的是程序的执行需要由系统事件来驱动。

![同步和异步](pic/image-4.png)

**半同步半异步模型**

半同步/半异步模式中，同步线程用于处理客户逻辑中的逻辑单元；异步线程用于处理I/O事件异步线程监听到客户请求后，就将其封装成请求对象并插入请求队列中。请求队列将通知某个工作在同步模式的工作线程来读取并处理该请求对象。具体选择哪个工作线程来为新的客户请求服务，则取决于请求队列的设计。

**半同步反应堆**
半同步/半反应堆并发模式是半同步/半异步的变体，将半异步具体化为某种事件处理模式.

半同步/半异步模式工作流程
>同步线程用于处理客户逻辑
>异步线程用于处理I/O事件
>异步线程监听到客户请求后，就将其封装成请求对象并插入请求队列中
>请求队列将通知某个工作在**同步模式的工作线程**来读取并处理该请求对象

半同步/半反应堆工作流程（以Proactor模式为例）
>主线程充当异步线程，负责监听所有socket上的事件
>若有新请求到来，主线程接收之以得到新的连接socket，然后往epoll内核事件表中注册该socket上的读写事
>如果连接socket上有读写事件发生，主线程从socket上接收数据，并将数据封装成请求对象插入到请求队列中
>所有工作线程睡眠在请求队列上，当有任务到来时，通过竞争（如互斥锁）获得任务的接管权

## 线程池
[实现地址](http://chenfeifei.online/2023/08/11/c-11-xian-cheng-chi/)
